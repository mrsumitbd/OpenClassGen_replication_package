class DynamoMappings(object):
    '''Attribute mapping class.

    DynamoDB has some opinions about what you can store or query in an
    attribute. We're going to use mappings to fix that.
    '''

    @staticmethod
    def map_index_val(index_val):
        '''Xform index_val so that it can be stored/queried.'''
        if index_val is None:
            return None
        elif isinstance(index_val, bool):
            return str(index_val).lower()
        elif isinstance(index_val, (int, float)):
            return str(index_val)
        elif isinstance(index_val, str):
            return index_val if index_val else " "
        elif isinstance(index_val, (list, tuple)):
            return [DynamoMappings.map_index_val(item) for item in index_val]
        elif isinstance(index_val, dict):
            return {k: DynamoMappings.map_index_val(v) for k, v in index_val.items()}
        else:
            return str(index_val)

    @staticmethod
    def unmap_stored_val(stored_val):
        '''Inverse of index_val_mapping.

        Note that we currently don't use it because we don't actually read back
        index values (since they are generated by Python functions).
        '''
        if stored_val is None:
            return None
        elif stored_val == " ":
            return ""
        elif stored_val == "true":
            return True
        elif stored_val == "false":
            return False
        elif isinstance(stored_val, str):
            try:
                if '.' in stored_val:
                    return float(stored_val)
                else:
                    return int(stored_val)
            except ValueError:
                return stored_val
        elif isinstance(stored_val, list):
            return [DynamoMappings.unmap_stored_val(item) for item in stored_val]
        elif isinstance(stored_val, dict):
            return {k: DynamoMappings.unmap_stored_val(v) for k, v in stored_val.items()}
        else:
            return stored_val